开启三个线程：
	A线程输出A B线程输出B C线程输出C
	控制台输出ABC/BAC/CAB/BCA/CBA/ACB
	线程争抢cpu，直接执行代码，执行完销毁，cpu随意调度
1.并发和并行：
	并发：cpu调度线程快速切换，提高cpu运行的效率
	并行：同一时刻一起执行（多cpu 分布式 大数据）
2.同步和异步：
	同步：程序A执行完程序B才能执行
	异步：程序A和程序B之间不受影响互不干扰，线程完成（JSP同步 vue异步 AJAX异步）
3.线程和进程：
	进程是正在运行的应用，同一个进程是独享内存内容空间，cpu调度资源的基本单位
	线程是进程子任务，没有独立的资源，cpu调度资源的最小单位
4.run()和start() 有什么区别
	run是线程执行的代码，直接调用，还是main线程的方法
	start()启动线程，执行run()
5.线程不安全是什么？
	发生的条件 1）多线程 2）共享资源 3）数据写操作
	如何解决	1）同步代码块 2）同步方法
		同步就是加锁，在执行这段代码期间cpu不会丢，那么cpu的执行效率低
				尽可能减少同步代码块里的代码
		不要锁循环
			while(){
				同步代码块{
					if(判断)
				}
			}
	锁对象随意，必须同一把锁，静态方法锁为类名.class,非静态方法为 this
6.互斥锁：我执行其他人不能执行
7.线程实现的方式
	1）继承Thread，耦合度高，只能有一个父类，无法继承其他类（不常用）
	2）实现Runable接口，耦合度低
8.sleep和wait有什么区别？
	sleep是睡眠阻塞，自己到时间，自己醒
	wait()阻塞，直到别人notify()，才唤醒
9.wait() notify() notifyAll() 为什么是Object，而不是Thread的方法
	线程等待，线程唤醒，为什么不是线程.wait() 或者 线程.notify()
	线程通信，每个线程的业务比较复杂
	A线程业务和B线程业务比较复杂，线程不安全，加锁
	线程通信一定实在同步代码块上通信的，必须加锁，线程一定实在线程安全，才能通信
	A线程获得B，现在A线程执行中等待，触发B线程的执行，可是锁在A的手上，B获得cpu，
	但没有锁，B无法执行，wait() 锁从A这结束让B获得锁
		三个方法其实都是对锁的操作，通过控制锁来控制线程，锁对象随意，
		三个方式每个对象都能有，随意在Object中继承
10.同步阻塞 和睡眠阻塞的区别
	同步是线程安全
11.线程通信：生产者消费者模式线程通信
12.线程是操作系统的开		
	循环不接数，不执行下面的代码，调其他线程，等待其他线程把我唤醒
	只是让操作系统开线程，线程任何执行，cpu调度，cpu先执行主线程，主线程的优先高
13.如果线程比较多，服务器，有一个客户来了，开一个线程，客户走了，关线程，反反复复开，操作系统低
	缓冲区：一次性开50个线程，客户给个线程对象，回收线程
		   给下一个客户用，对于操作系统，50个线程就够了
		   称为线程池
	提高线程的效率
14.网络
	单机形式，通联互通，电脑形成通路，基础架构，局域网OK
	程序的网络通信：
		网络三要素：
				ip：标识唯一的电脑 ipconfig(ifconfig) 10.40.7.5 ping ip是否联通
					127.0.0.1 本机ip 回环测试地址 localhost 本机
				端口号：标识唯一的软件  qq聊天0-65535  程序端口号  尽量大一点 一般应用都用了
		
				通信协议：TCP/IP 和 UDP 两大协议
						TCP/IP：三次握手协议，安全的
								A和B 通信，A->B 你在吗 B->A 我在 A->B 数据 
								（四次结束）
						UDP：广播式，不管你在不在 直接发生，不安全
				QQ飞车 都用 TCP/IP UDP协议
					TCP/IP 慢，安全
					UDP 快，不安全（多媒体，丢包OK）
		7层模型  OSI/4层模型（标准）/TCP/IP模型（行业）
			应用层						应用层
			表示层						输出层
			会话层						网络层
			传输层						数据链路层
			网络层
			链路层
			物理层
		
		
	
	
	
	
	
	
		
	
	
	
	