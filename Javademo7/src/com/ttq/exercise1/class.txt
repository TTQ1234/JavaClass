类的实例化对象的过程

先加载类模版，给静态的变量开辟空间，调用执行静态代码块，
通过关键new在堆中开辟空间，执行构造代码块，执行构造方法


当多个类之间的代码有相同的代码，那么提取，这个类叫父类或者基类
子类继承父类，就继承父亲的一切
子类实例化对象，先实例化父类，在实例化子类
先加载父亲和孩子的类模块，先实例化父亲，然后再实例化孩子


this:是我 this.变量=我的属性  this（）我的构造方法
super：我的父亲 super.变量=我父亲的属性 super（）我父亲的构造方法


1、一个类实例化new 对象的过程

   类加载，只会加载一次（给static修饰的变量开空间，static的方法定义，执行static的代码块）
   new开空间（属性开空间，普通方法定义）
   执行构造代码块，调用构造方法给属性赋值，返回实例化后的对象

2、static类所有，静态类
   修饰变量，类变量，类名。**调用，所有对象共享
   id自增长，static sid 类变量=1000
   scanner sc = new scanner() //
   sout out是system的什么 out是类变量
   math。random 是static修饰方法
   
   如果一个类的构造方法私有化，那么这个类外部不能实例化对象，就能调用的对象的属性和方法
   那么所有的属性和方法都必须static修饰，变成类变量和方法，由类名.***调用
   
   如果一个类的构造方法私有化，那么外部肯定不能实例化对象的，system，math，runtime
       1）类中的所有和方法全部是静态的，归类所有，类型，类名.***：system，math
       2）runtime使用了单例模式：自己内部实例化对象，然后以get方法返回对象
   静态的东西在类加载的时候就开辟空间，静态只能调用静态，非静态可以调用静态
   
 3、单例模式：只能有一个实例
         1）构造方法私有化
         2）自己内部提供一个本类对象（final）
         3）以get方法返回该对象
   
   枚举：只能由固定个数的实例
   
        enum Gender{
         WOMAN,MAN
        }
        ->编译成class
        编译后的代码
        
        class Gender{
        private static final Gender woman = new Gender();
        private static final Gender man = new Gender();
        public static Gender getWoman(){return woman;}
        public static Gender getMan(){return man;}
        private Gender(){}
        }
   
4、继承：将多个类的公共代码提取出来形成父类/基类
        这个类只要继承父类就可以继承父类的属性和方法
        
    通过extends关键字继承
    继承是把双刃剑，用得好可以封装的好，缺点：耦合度高
    （开发：高内聚，底耦合）
    
5、如果子类和父亲的属性同名 就近原则

6、父亲的私有的方法孩子继承不了，私有的属性，还有可以通过getter和setter方法获得
   如果实例化孩子方法，调用父亲构造方法，在父亲构造方法里面调用了孩子重写的方法，那么执行孩子的方法
   在这个方法里面用到的属性是父亲和孩子都有的属性，那么这个属性是孩子的
   但此时正在实例化父亲，孩子还没有生成，所以这个属性值为默认值0 

10、重写
    子类重写父亲的方法，子类和父类方法同名，子类重写编写了父亲的方法

总结：
     继承：子类继承父类，那么继承父亲的属性和方法
          如果方法为私有，那么不能继承，如果属性为私有，可以通过getter setter方法
     如果这个类不想有子类，final修饰，final修饰的类不能被继承
     如果父亲的属性和儿子的属性一样，那么this.属性 自己属性，super是父亲的属性
     如果儿子的方法和父亲的方法一样，那么就是儿子重写了父亲的方法
     
     class Person（）{
     int age；}
     class child extends person（）
     
     age是属性，成员变量，实例变量，对象变量，new对象的时候开空间

11、访问权限
           private     默认       protected      public       
           私有的      
同包
   其他类   不能         能          能             能
   子类     不能         能          能             能

异包
   其他类    不能       不能         不能            能
   子类      不能       不能         能             能
  
 private < 默认 < protected < public
 
 
 
 12)重写：子类重写父类的方法，两同两小，一大原则
         方法名和参数必须相同，是同一个方法
         两小：子类的返回类型比父类的子类小
         一大：子类的访问权限必须比父类大
      正常重写是一样
         
         
         
