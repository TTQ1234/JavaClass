1.面向对象的三大特性
  	封装：属性私有化，提供setter和getter方法提供给外部访问
  	继承：提取多个类的公共代码为父类，子类恶意继承父类的一切
  	多态：一个类型多种形态，父类引用指向子类对象
     	  Animal a = new Cat()
      	 针对a这个对象，可以是cat对象，可以是animal对象，多种形态
       
2.继承：
	2.1访问权限：private 默认 protected public
	2.2一个子类实例化对象的过程
		类加载：先加载父类模版，再加载子类模版，执行static代码块，给static属性赋值
		实例化隐含父类对象：调用父类的构造代码块，构造方法实例化父类对象，默认super，注意是父类的默认构造
		实例化本类对象：自己的构造代码块，构造方法实例化本类对象
		
		父类对象是隐藏的，外部不可见，自己内部可能会调用一下
	2.3父亲属性和方法私有
		1）构造方法私有化，无子类：父亲无法初始化，不能实例化子类对象
		2）普通方法私有化：孩子没法继承和重写
		3）属性私有化：孩子通过getter和setter方法访问
	2.4 static  关键字
		static关键字是类的资源，与继承无关，调用的方式 类名.***
		静态资源只能访问静态的，不能访问非静态的
	2.5 final
		可以修饰变量，不能修改，可以修饰类，不能继承，可以修饰方法，不能重写
	2.6 重写
		子类重写父类的方法：两同两小一大原则
		
3.多态
	一种事物多种形态，父类引用指向子类对象
	Animal a = new Cat()
	a.name=？
	
	属性编译看左边（检查有没有该属性，没有编译不通过），运行看右边
	方法编译看左边（父类有没有该方法，没有编译不通过），运行看右边（运行儿子的方法）


5.抽象类
	Account 账户父类，存款和取款，没有业务（基本有基本的取款存款，信用有信用的取款存款）
	父类方法没有任何实现的页面，抽象方法
	abstract 修饰方法，那么该方法无业务，需要子类重写
	如果一个类有抽象方法，那么这个类也是抽象类，abstract修饰，不能实例化对象

6.总结：抽象类
	一班父亲都是抽象类，依赖于抽象不要依赖于具体，就是为了解开耦合度
	如果一个类的方法抽象，那么这个类就是抽象类，抽象类里面可以没有抽象方法
	抽象类不能实例化对象，但是有构造方法，给子类实例化对象suoer（）
	抽象父类的作用就是为了约束子类应该具备的方法，让子类必须重写
	如果一个子类没有全部重写父类的全部方法，那么该子类也是抽象的




	